@Module
package org.w3c.dom;

import org.w3c.event.EventTarget;
import org.w3c.html.HTMLElement;
import org.w3c.dom.css.CSSStyleDeclaration;
//File: dom.idl

//#ifndef _DOM_IDL_
//#define _DOM_IDL_
//
//#pragma prefix "w3c.org"  
//module dom
//{

//valuetype String sequence<unsigned short>;
//
//typedef  unsigned long long DOMTimeStamp;

//public interface DocumentType;
//public interface Document;
//public interface NodeList; 
//public interface NamedNodeMap;
//public interface Element;

public native class DOMException extends RuntimeException{
	// ExceptionCode
	public native static final /*unsigned */short   INDEX_SIZE_ERR  = 1;
	public native static final /*unsigned */short   DOMSTRING_SIZE_ERR  = 2;
	public native static final /*unsigned */short   HIERARCHY_REQUEST_ERR     = 3;
	public native static final /*unsigned */short   WRONG_DOCUMENT_ERR  = 4;
	public native static final /*unsigned */short   INVALID_CHARACTER_ERR     = 5;
	public native static final /*unsigned */short   NO_DATA_ALLOWED_ERR = 6;
	public native static final /*unsigned */short   NO_MODIFICATION_ALLOWED_ERR  = 7;
	public native static final /*unsigned */short   NOT_FOUND_ERR  = 8;
	public native static final /*unsigned */short   NOT_SUPPORTED_ERR  = 9;
	public native static final /*unsigned */short   INUSE_ATTRIBUTE_ERR = 10;
	// Introduced in DOM Level 2:
	public native static final /*unsigned */short   INVALID_STATE_ERR  = 11;
	// Introduced in DOM Level 2:
	public native static final /*unsigned */short   SYNTAX_ERR    = 12;
	// Introduced in DOMfinal vel 2:
	public native static final /*unsigned */short   INVALID_MODIFICATION_ERR    = 13;
	// Introduced in DOM Level 2:
	public native static final /*unsigned */short   NAMESPACE_ERR  = 14;
	// Introduced in DOM Level 2:
	public native static final /*unsigned */short   INVALID_ACCESS_ERR  = 15;
	
	// Introduced in DOM Level 3:
//	const unsigned 
	public native static final short   VALIDATION_ERR  = 16;
	// Introduced in DOM Level 3:
//	const unsigned 
	public native static final short   TYPE_MISMATCH_ERR  = 17;
 /*unsigned */short  code;
}

//Introduced in DOM Level 3:
public native interface DOMStringList {
	public native String item(final /*unsigned*/ long index);
//	readonly attribute unsigned 
	public native long  length{}
	public native boolean contains(final String str);
}


public native interface DOMImplementation {
	public native boolean hasFeature(final String feature, final String version);
	// Introduced final DOM Level 2:
	public native DocumentType createDocumentType(final String qualifiedName, final String publicId, final String systemId) throws DOMException;
	// Introduced final DOM Level 2:
	public native Document createDocument(final String namespaceURI, final String qualifiedName, final DocumentType doctype) throws DOMException;
}

public native interface DocumentFragment extends Node {
    //Selector API
    native HTMLElement querySelector(String selectors);
    native NodeList querySelectorAll(String selectors);
}

public native interface Node extends EventTarget, Bindable{

	// NodeType
	public native short ELEMENT_NODE   = 1; 
	public native short ATTRIBUTE_NODE  = 2;
	public native short TEXT_NODE    = 3;
	public native short CDATA_SECTION_NODE  = 4;
	public native short ENTITY_REFERENCE_NODE     = 5;
	public native short ENTITY_NODE   = 6;
	public native short PROCESSING_INSTRUCTION_NODE  = 7;
	public native short COMMENT_NODE   = 8;
	public native short DOCUMENT_NODE  = 9;
	public native short DOCUMENT_TYPE_NODE  = 10;
	public native short DOCUMENT_FRAGMENT_NODE     = 11;
	public native short NOTATION_NODE  = 12;

 	// readonly attribute 
 	public native String nodeName{}
 	//     attribute 
 	public native String nodeValue{}
     // throws DOMException on setting
     // throws DOMException on retrieval
 	// readonly attribute /*unsigned */
 	public native short nodeType{}
 	// readonly attribute 
 	public native Node parentNode{}
 	// readonly attribute 
 	public native NodeList childNodes{}
 	// readonly attribute 
 	public native Node firstChild{}
 	// readonly attribute 
 	public native Node lastChild{}
 	// readonly attribute 
 	public native Node previousSibling{}
 	// readonly attribute 
 	public native Node nextSibling{}
 	// readonly attribute 
 	public native NamedNodeMap attributes{}
 	// Modified in DOM Level 2:
 	// readonly attribute 
 	public native Document ownerDocument{}
 	/**
 	 * 
 	 * @param newChild
 	 * @param refChild
 	 * @return new Child
 	 * @throws DOMException
 	 */
 	public native Node insertBefore(final Node newChild, final Node refChild) throws DOMException;
 	public native Node replaceChild(final Node newChild, final Node oldChild) throws DOMException;
 	public native Node removeChild(final Node oldChild) throws DOMException;
// 	public native Node appendChild(final Node newChild) throws DOMException;
 	public native Node appendChild(final Bindable newChild) throws DOMException;
 	public native boolean hasChildNodes();
 	public native Node cloneNode(final boolean deep);
 	// Modified in DOM Level 2:
 	public native void normalize();
 	// Introduced in DOM Level 2:
 	public native boolean isSupported(final String feature, final String version);
 	// Introduced in DOM Level 2:
 	// readonly attribute 
 	public native String namespaceURI{}
 	// Introduced in DOM Level 2:
 	//   attribute
 	public native String prefix{}
   // throws DOMException on setting

 	// Introduced in DOM Level 2:
 	// readonly attribute 
 	public native String localName{}
 	// Introduced in DOM Level 2:
 	public native boolean hasAttributes();
 	
 	public default Binding getBinding(String[] properties){
    	Map<String, Binding> bindings = (Map<String, Binding>) this["__bindings"];
    	if(bindings == null){
    		return null;
    	}
    	return bindings.get(properties.join("."));
    }
	    
 	public default void setBinding(String[] properties, Binding binding){
    	Map<String, Binding> bindings = (Map<String, Binding>) this["__bindings"];
    	if(bindings == null){
    		this["__bindings"] = bindings = new Map<String, Binding>();
    	}
    	Binding old = bindings.get(properties.join("."));
    	if(old === binding){
    		return;
    	}
    	
    	if(old != null){
        	old.unInject(this);
    	}
    	
    	bindings.set(properties.join("."), binding);
    	binding.inject(this, properties);
    }
	    
 	public default boolean removeBinding(String[] properties){
    	Map<String, Binding> bindings = (Map<String, Binding>) this["__bindings"];
    	if(bindings == null){
    		return false;
    	}
    	
    	Binding old = bindings.get(properties.join("."));
    	if(old == null){
    		return false;
    	}
    	
    	if(old != null){
        	old.unInject(this);
    	}
    	
    	bindings.delete(properties.join("."));
    	return true;
    }
	    
    //cym 2015-05-07
	public default void attach(Binding binding){
		// listen for lost focus and input 
		switch(binding.trigger) { 
			case LostFocus:
				this.addEventListener("blur", binding.updateSource, false);
				break; 
			case PropertyChanged: 
				this.addEventListener("input", binding.updateSource, false);
				this.addEventListener("change", binding.updateSource, false);
				break;
			default:
		 }  
	}
	  
	public default void detach(Binding binding){
		// listen for lost focus and input 
 		switch(binding.trigger) { 
			case LostFocus:
				this.removeEventListener("blur", binding.updateSource, false);
				break; 
			case PropertyChanged: 
				this.removeEventListener("input", binding.updateSource, false);
				this.removeEventListener("change", binding.updateSource, false);
				break;
			default:
		 }  
 	}
		
//	public default void update(Binding binding){
//		Object data = this.getDataContext(binding.context).dataItem;
//		if(!String.isNullOrEmpty(binding.property)){
//			data = data == null ? null : data[binding.property];
//		}
//
//		Object tag = this;
//		String[] properties = binding.targetProperties;
//		int length = properties.length; 
//		for(int i = 0 ; i < length - 1; i++){
//			if(tag == null) return;
//			tag = tag[properties[i]];
//		}
//			
//		if(binding.converterTo != null){
//			data = binding.converterTo(data);
//		}
//			
//		Object oldValue = tag[properties[length-1]];
//		if(data === oldValue){
//			return;
//		}
//			
//		if(binding.updateTargetCallback != null){
//			binding.updateTargetCallback(this, properties, data);
//		} else {
//			tag[properties[length-1]] = data;
//		}
//	}
	
//	public default void update(Binding binding){
//		Object data = this.getDataContext(binding.context).dataItem;
//		if(!String.isNullOrEmpty(binding.property)){
//			data = data == null ? null : data[binding.property];
//		}
//
//		Object tag = this;
//		String[] properties = binding.targetProperties;
//		int length = properties.length; 
//		
//		for(int i = 0 ; i < length - 1; i++){
//			if(tag == null) return;
//			tag = tag[properties[i]];
//			
//			if(tag == null && tag["getAttributeNS"] != null){
//				tag = ((Element)tag).getAttribute(properties[i]);
//			}
//			
//			if(tag == null && tag["getAttribute"] != null) {
//				tag = ((Element)tag).getAttribute(properties[i]);
//			} 
//			
//			if(tag == null && tag["getProperty"] != null){
//				tag = ((CSSStyleDeclaration)tag).getPropertyValue(properties[length-1]);
//			}
//		}
//			
//		if(binding.converteTo != null){
//			data = binding.converteTo(data);
//		}
//		
//		Object oldValue = tag[properties[length-1]];
//		if(oldValue === undefined){
//			if(tag["getAttributeNS"] != null){
//				oldValue = ((Element)tag).getAttribute(properties[length-1]);
//			} else if(tag["getAttribute"] != null) {
//				oldValue = ((Element)tag).getAttribute(properties[length-1]);
//			} else if(tag["getProperty"] != null){
//				oldValue = ((CSSStyleDeclaration)tag).getPropertyValue(properties[length-1]);
//			}
//		}
//		
//		if(data === oldValue){
//			return;
//		}
//			
//		if(binding.updateTargetCallback != null){
//			binding.updateTargetCallback(this, properties, data);
//		} else {
////			if(tag["setAttributeNS"] != null){
////				((Element)tag).setAttributeNS(null, properties[length-1], data);
////			} else 
////			if(tag["setAttribute"] != null) {
////				((Element)tag).setAttribute(properties[length-1], data);
////			} else if(tag["setProperty"] != null){
////				((CSSStyleDeclaration)tag).getPropertyValue(properties[length-1]);
////			} else {
//				tag[properties[length-1]] = data;
////			}
//		}
//	}
	
	public default void update(Binding binding){
		DataContext dc = this.getDataContext(binding.context);
		if(dc == null){
			console.log("the binding context[" + binding.context + "]" + "does not exists");
			return;
		}
		Object data = dc.dataItem;
//		Object data = this.getDataContext(binding.context).dataItem;
		if(!String.isNullOrEmpty(binding.property)){
			data = data == null ? null : data[binding.property];
		}

		Object tag = this;
		String[] properties = binding.targetProperties;
		
		
		int length = properties.length; 
		for(int i = 0 ; i < length - 1; i++){
			if(binding.attribute){
				tag = ((Element)tag).getAttribute(properties[i]);
			} else {
				tag = tag[properties[i]];
			}
			
			if(tag == null) return;
		}
			
		if(binding.converteTo != null){
			data = binding.converteTo(data);
		}
		
		Object oldValue = binding.attribute ? ((Element)tag).getAttribute(properties[length -1]) :  tag[properties[length-1]];
		
		if(data === oldValue){
			return;
		}
			
		if(binding.updateTargetCallback != null){
			binding.updateTargetCallback(this, properties, data);
		} else {
			if(binding.attribute){
				((Element)tag).setAttribute(properties[length-1], data);
			} else {
				tag[properties[length-1]] = data;
			}
		}
	}
	
	public DataContext dataContext{
		&{
			return (DataContext)this["__context"];
		}+{
			this["__context"] = value;
			addDataContext(value);
		}
	}
	    
	default public DataContext getDataContext(String name){
    	if(String.isNullOrEmpty(name)){
    		return null;
    	}
    	Map<String, DataContext> contexts = (Map<String, DataContext>) this["__contexts"];
    	if(contexts != null){
    		DataContext result = contexts.get(name);
    		if(result != null){
    			return result;
    		}
    	}
    	
    	if(this.logicParent != null){
        	return this.logicParent.getDataContext(name);
      	} else if(parentNode != null){
    		return this.parentNode.getDataContext(name);
    	}
    	
    	return null;
    }
	    
    default public void addDataContext(DataContext context){
    	Map<String, DataContext> contexts = (Map<String, DataContext>) this["__contexts"];
    	if(contexts == null){
    		this["__contexts"] = contexts = new Map<String, DataContext>();
    	}
    	
    	DataContext old = contexts.get(context.name);
    	if(old != null){
    		old.moveDependentTo(context);
    	}
    	
    	contexts.set(context.name, context);
   	
    	if(context.name == "ROOT" || context.name == "TEMPLATE" || context.ancestor == null){
    		return;
    	}
    	
    	if(this.logicParent != null){
        	DataContext parent = this.logicParent.getDataContext(context.ancestor);
        	if(parent != null){
        		parent.addDependent(context);
        	} else {
        		console.log("the ancestor DataContext with [" + 
        				context.ancestor + "] in DataContext[" + context.name + "] does not exists!");
        	}
    	} else if(this.parentNode != null){
        	DataContext parent = this.parentNode.getDataContext(context.ancestor);
        	if(parent != null){
        		parent.addDependent(context);
        	} else {
        		console.log("the ancestor DataContext with [" + 
        				context.ancestor + "] in DataContext[" + context.name + "] does not exists!");
        	}
    	}
    }
	    
    default public void removeDataContext(String name){
    	if(String.isNullOrEmpty(name)){
    		return;
    	}
    	
       	Map<String, DataContext> contexts = (Map<String, DataContext>) this["__contexts"];
    	if(contexts == null){
    		return;
    	}
    	DataContext context = contexts.get(name);
    	if(context != null){
    		context.clearDependents();
    		
    		if(logicParent != null){
    			DataContext parent = this.logicParent.getDataContext(context.ancestor);
            	if(parent != null){
            		parent.addDependent(context);
            	} else {
            		console.log("ancestor of DataContext[" + context.ancestor + "] does not exists!");
            	}
    		} else if(this.parentNode != null){
            	DataContext parent = this.parentNode.getDataContext(context.ancestor);
            	if(parent != null){
            		parent.addDependent(context);
            	} else {
            		console.log("ancestor of DataContext[" + context.ancestor + "] does not exists!");
            	}
        	}
        	contexts.delete(name);
    	}
    }
	    
    public Bindable logicParent{
    	&{
    		return (Bindable)this["_logicParent"];
    	}
    	+{
    		this["_logicParent"] = value;
    	}
    }
    
    default public void addLogicChild(Bindable child){
    	Array<Bindable> tags = (Array<Bindable>) this["_logicChilds"];
    	if(tags == null){
    		this["_logicChilds"] = tags = new Array<Bindable>();
    	}
    	tags.push(child);
    }
    
    default public void remmoveLogicChild(Bindable child){
    	Array<Tag> tags = (Array<Tag>) this["_logicChilds"];
    	if(tags != null){
    		tags.forEach((Tag tag, int index, Array<Tag> array)->{
    			if(tag == child){
    				tags.splice(index, 1);
    			}
    		});
    	}
    }
  
    default public void reset(){
//    	if(this.childNodes != null){
//        	for(long i = 0, len = this.childNodes.length; i<len; i++){
//        		this.childNodes[i].reset(); 
//        	}
//    	}
    	while(this.firstChild != null){
    		this.firstChild.reset(); 
    	}
    	
    	Map<String, Binding> bindings = (Map<String, Binding>) this["__bindings"];
		if(bindings != null){
			bindings.forEach((Binding binding, String key, Map<String, Binding> map)->{
				binding.reset();
			});
		}
		
		Map<String, DataContext> contexts = (Map<String, DataContext>) this["__contexts"];
		if(contexts != null){
			contexts.forEach((DataContext context, String key, Map<String, DataContext> mapObj)->{
				context.reset(this);
			});
		}
		
		Array<Bindable> tags = (Array<Bindable>) this["_logicChilds"];
    	if(tags != null){
    		tags.forEach((Bindable tag, int index, Array<Bindable> array)->{
    			tag.reset();
    		});
    	}
    	this.parentNode.removeChild(this);
	}
    
    //DOM 4
//  attribute  
	public native String textContent{&{}+;}
}

public native interface NodeList {
//	Node item(final /*unsigned */long index);
	public native Node this[long index]; 
	// readonly attribute /*unsigned */
	public native long length{}
}

public native interface NamedNodeMap {
	public native Node getNamedItem(final String name);
	public native Node setNamedItem(final Node arg) throws DOMException;
	Node removeNamedItem(final String name) throws DOMException;
	public native Node item(final /*unsigned */long index);
	// readonly attribute /*unsigned */
	public native long length{}
	// Introduced final DOM Level 2:
	public native Node getNamedItemNS(final String namespaceURI, final String localName);
	// Introduced final DOM Level 2:
	public native Node setNamedItemNS(final Node arg) throws DOMException;
	// Introduced final DOM Level 2:
	public native Node removeNamedItemNS(final String namespaceURI, final String localName) throws DOMException;
}

public native interface CharacterData extends Node {
	//attribute 
	public native String data{}
   // throws DOMException on setting
  // throws DOMException on retrieval

	// readonly attribute /*unsigned */
	public native long length{}
	public native String substringData(final /*unsigned */long offset, final /*unsigned */long count) throws DOMException;
	public native void appendData(final String arg) throws DOMException;
	public native void insertData(final /*unsigned */long offset, final String arg) throws DOMException;
	public native void deleteData(final /*unsigned */long offset, final /*unsigned */long count)throws DOMException;
	public native void replaceData(final /*unsigned */long offset, final /*unsigned */long count, final String arg) throws DOMException;
}

public native interface Attr extends Node {
	// readonly attribute 
	public native String name{}
	// readonly attribute 
	public native boolean specified{}
	//attribute 
	public native String value{}
     // throws DOMException on setting

 // Introduced in DOM Level 2:
// readonly attribute 
	public Element ownerElement{}
}

public native interface Element extends Node {
	// readonly attribute 
	public native String tagName{}
	public native String getAttribute(final String name);
	public native void setAttribute(final String name, final String value) throws DOMException;
	public native void removeAttribute(final String name) throws DOMException;
	public native Attr getAttributeNode(final String name);
	public native Attr setAttributeNode(final Attr newAttr) throws DOMException;
	public native Attr removeAttributeNode(final Attr oldAttr) throws DOMException;
	public native NodeList getElementsByTagName(final String name);
	// Introduced final DOM Level 2:
	public native String getAttributeNS(final String namespaceURI, final String localName);
	// Introduced final DOM Level 2:
	public native void setAttributeNS(final String namespaceURI, final String qualifiedName, final String value) throws DOMException;
	// Introduced final DOM Level 2:
	public native void removeAttributeNS(final String namespaceURI,final String localName) throws DOMException;
	// Introduced final DOM Level 2:
	public native Attr getAttributeNodeNS(final String namespaceURI, final String localName);
	// Introduced final DOM Level 2:
	public native Attr setAttributeNodeNS(final Attr newAttr) throws DOMException;
	// Introduced final DOM Level 2:
	public native NodeList getElementsByTagNameNS(final String namespaceURI, final String localName);
	// Introduced in DOM Level 2:
	public native boolean hasAttribute(final String name);
	// Introduced final DOM Level 2:
	public native boolean hasAttributeNS(final String namespaceURI, final String localName);
}

public native interface Text extends CharacterData {
	Text splitText(final /*unsigned */long offset) throws DOMException;
}

public native interface Comment extends CharacterData {
}

public native interface CDATASection extends Text {
}

public interface DocumentType extends Node {
	// readonly attribute 
	public native String name{}
	// readonly attribute 
	public native NamedNodeMap entities{}
	// readonly attribute 
	public native NamedNodeMap notations{}
	// Introduced in DOM Level 2:
	// readonly attribute 
	public native String publicId{}
	// Introduced in DOM Level 2:
	// readonly attribute 
	public native String systemId{}
	// Introduced in DOM Level 2:
	// readonly attribute 
	public native String internalSubset{}
}

public interface Notation extends Node {
	// readonly attribute 
	public native String publicId{}
	// readonly attribute 
	public native String systemId{}
}

public interface Entity extends Node {
	// readonly attribute 
	public native String publicId{}
	// readonly attribute 
	public native String systemId{}
	// readonly attribute 
	public native String notationName{}
}

public interface EntityReference extends Node {
}

public native interface ProcessingInstruction extends Node {
	// readonly attribute 
	public native String target{}
	//     attribute 
	public native String data{}
     // throws DOMException on setting

}

public native interface Document extends Node, EventTarget {
	// readonly attribute 
	public native DocumentType doctype{}
	// readonly attribute 
	public native DOMImplementation implementation{}
	// readonly attribute 
	public native Element documentElement{}
	public native Element createElement(final String tagName) throws DOMException;
	public native DocumentFragment createDocumentFragment();
	public native Text createTextNode(final String data);
	public native Comment createComment(final String data);
	public native CDATASection createCDATASection(final String data) throws DOMException;
	public native ProcessingInstruction createProcessingInstruction(final String target, final String data) throws DOMException;
	public native Attr createAttribute(final String name) throws DOMException;
	public native EntityReference createEntityReference(final String name) throws DOMException;
	public native NodeList getElementsByTagName(final String tagname);
	// Introduced final DOM Level 2:
	public native Node importNode(final Node importedNode, final boolean deep) throws DOMException;
	// Introduced final DOM Level 2:
	public native Element createElementNS(final String namespaceURI, final String qualifiedName) throws DOMException;
	// Introduced final DOM Level 2:
	public native Attr createAttributeNS(final String namespaceURI, final String qualifiedName) throws DOMException;
	// Introduced final DOM Level 2:
	public native NodeList getElementsByTagNameNS(final String namespaceURI, final String localName);
	// Introduced final DOM Level 2:
	public native Element getElementById(final String elementId);
	
    //Selector API
	public native  Element querySelector(String selectors);
	public native  NodeList querySelectorAll(String selectors);
    
	public native Element elementFromPoint(final /*unsigned*/ long x, final /*unsigned*/ long y);
}

